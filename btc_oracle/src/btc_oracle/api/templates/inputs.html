<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Oracle Inputs</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body { background-color: #f8f9fa; }
        .card { border: none; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .table thead th { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.04em; }
        .table td { vertical-align: middle; font-size: 0.85rem; }
        .sticky-head thead th { position: sticky; top: 0; background: #f8f9fa; z-index: 1; }
        .small-muted { font-size: 0.8rem; color: #6c757d; }
        .gap-bad { color: #dc3545; font-weight: 600; }
    </style>
</head>
<body>
    <nav class="navbar navbar-dark bg-dark mb-4">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1"><i class="fas fa-filter me-2"></i><span data-i18n="brand">Model Inputs</span></span>
            <div class="d-flex align-items-center gap-2">
                <a class="btn btn-outline-light btn-sm" href="/" data-i18n="nav_dashboard">Dashboard</a>
                <a class="btn btn-outline-light btn-sm" href="/models" data-i18n="nav_models">Models</a>
                <a class="btn btn-outline-light btn-sm" href="/patterns" data-i18n="nav_patterns">Patterns</a>
                <select class="form-select form-select-sm bg-dark text-light border-secondary" id="lang-select" aria-label="Language" style="width: 86px;">
                    <option value="en">EN</option>
                    <option value="ru">RU</option>
                </select>
                <span class="text-light" id="connection-status"><span class="badge bg-success" data-i18n="status_connected">Connected</span></span>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="row mb-4">
            <div class="col-md-12">
                <div class="d-flex justify-content-between align-items-center">
                    <h5 class="text-muted mb-0"><span data-i18n="last_updated">Last Input Snapshot</span>: <span id="last-updated">--:--:--</span> <small class="text-muted">(<span data-i18n="local">local</span>)</small></h5>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="autoRefresh" checked>
                        <label class="form-check-label" for="autoRefresh" data-i18n="auto_refresh">Auto-refresh (1s)</label>
                    </div>
                </div>
                <div class="small-muted mt-2" id="snapshot-meta" data-i18n="snapshot_meta_empty">Timeframe: -- | Window: -- | Feature dim: --</div>
                <div class="small-muted mt-1" data-i18n="live_note">LIVE row = partial candle (not used for training).</div>
            </div>
        </div>

        <div class="row">
            <div class="col-lg-6">
                <div class="card p-3">
                    <h5 class="mb-3" data-i18n="feature_vector_title">Feature Vector (normalized)</h5>
                    <div class="table-responsive" style="max-height: 420px; overflow: auto;">
                        <table class="table table-sm table-striped sticky-head" id="features-table">
                            <thead>
                                <tr>
                                    <th data-i18n="table_feature">Feature</th>
                                    <th data-i18n="table_value">Value</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="col-lg-6">
                <div class="card p-3">
                    <h5 class="mb-3" data-i18n="candles_title">Candles (model window)</h5>
                    <div class="table-responsive" style="max-height: 420px; overflow: auto;">
                        <table class="table table-sm table-striped sticky-head" id="candles-table">
                            <thead>
                                <tr>
                                    <th data-i18n="table_close_time">Close Time</th>
                                    <th>Δm</th>
                                    <th data-i18n="table_open">Open</th>
                                    <th data-i18n="table_high">High</th>
                                    <th data-i18n="table_low">Low</th>
                                    <th data-i18n="table_close">Close</th>
                                    <th data-i18n="table_volume">Volume</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const LANG_KEY = 'titan_ui_lang';
        const I18N = {
            en: {
                title: 'BTC Oracle Inputs',
                brand: 'Model Inputs',
                nav_dashboard: 'Dashboard',
                nav_models: 'Models',
                nav_patterns: 'Patterns',
                status_connected: 'Connected',
                status_disconnected: 'Disconnected',
                status_waiting: 'Waiting for data',
                last_updated: 'Last Input Snapshot',
                local: 'local',
                auto_refresh: 'Auto-refresh (1s)',
                snapshot_meta_empty: 'Timeframe: -- | Window: -- | Feature dim: --',
                live_note: 'LIVE row = partial candle (not used for training).',
                feature_vector_title: 'Feature Vector (normalized)',
                candles_title: 'Candles (model window)',
                table_feature: 'Feature',
                table_value: 'Value',
                table_close_time: 'Close Time',
                table_open: 'Open',
                table_high: 'High',
                table_low: 'Low',
                table_close: 'Close',
                table_volume: 'Volume',
                meta_timeframe: 'Timeframe',
                meta_window: 'Window',
                meta_feature_dim: 'Feature dim',
                meta_close: 'Close',
                meta_atr: 'ATR',
                meta_market: 'Market',
                meta_volume: 'Volume',
                meta_live: 'Live: close in {seconds}s, age {age}',
                live_tag: 'LIVE',
                no_features: 'No features',
                no_candles: 'No candles',
            },
            ru: {
                title: 'BTC Oracle Входы',
                brand: 'Входы модели',
                nav_dashboard: 'Дашборд',
                nav_models: 'Модели',
                nav_patterns: 'Паттерны',
                status_connected: 'Подключено',
                status_disconnected: 'Нет связи',
                status_waiting: 'Ожидание данных',
                last_updated: 'Последний снимок входов',
                local: 'лок.',
                auto_refresh: 'Авто-обновление (1с)',
                snapshot_meta_empty: 'Таймфрейм: -- | Окно: -- | Размер фич: --',
                live_note: 'Строка LIVE = незакрытая свеча (не используется в обучении).',
                feature_vector_title: 'Вектор фич (нормализ.)',
                candles_title: 'Свечи (окно модели)',
                table_feature: 'Фича',
                table_value: 'Значение',
                table_close_time: 'Время закрытия',
                table_open: 'Open',
                table_high: 'High',
                table_low: 'Low',
                table_close: 'Close',
                table_volume: 'Объем',
                meta_timeframe: 'Таймфрейм',
                meta_window: 'Окно',
                meta_feature_dim: 'Размер фич',
                meta_close: 'Close',
                meta_atr: 'ATR',
                meta_market: 'Рынок',
                meta_volume: 'Объем',
                meta_live: 'Live: закрытие через {seconds}s, возраст {age}',
                live_tag: 'LIVE',
                no_features: 'Нет фич',
                no_candles: 'Нет свечей',
            }
        };
        let connectionState = 'connected';
        let currentLang = null;

        function detectLang() {
            const saved = localStorage.getItem(LANG_KEY);
            if (saved) return saved;
            const browserLang = (navigator.language || '').toLowerCase();
            return browserLang.startsWith('ru') ? 'ru' : 'en';
        }

        function t(key, vars) {
            const dict = I18N[currentLang] || I18N.en;
            let text = dict[key] || I18N.en[key] || key;
            if (vars) {
                Object.keys(vars).forEach((k) => {
                    text = text.replace(new RegExp(`\\{${k}\\}`, 'g'), String(vars[k]));
                });
            }
            return text;
        }

        function applyTranslations(root = document) {
            root.querySelectorAll('[data-i18n]').forEach((el) => {
                el.textContent = t(el.dataset.i18n);
            });
            root.querySelectorAll('[data-i18n-title]').forEach((el) => {
                el.title = t(el.dataset.i18nTitle);
            });
        }

        function setLanguage(lang) {
            currentLang = I18N[lang] ? lang : 'en';
            localStorage.setItem(LANG_KEY, currentLang);
            document.documentElement.lang = currentLang;
            document.title = t('title');
            applyTranslations();
            setConnectionStatus(connectionState);
        }

        function setConnectionStatus(state) {
            connectionState = state;
            const el = document.getElementById('connection-status');
            if (!el) return;
            if (state === 'connected') {
                el.innerHTML = `<span class="badge bg-success">${t('status_connected')}</span>`;
            } else if (state === 'waiting') {
                el.innerHTML = `<span class="badge bg-warning text-dark">${t('status_waiting')}</span>`;
            } else {
                el.innerHTML = `<span class="badge bg-danger">${t('status_disconnected')}</span>`;
            }
        }

        const API_URL = '/api/inputs/latest';
        const AUTO_REFRESH_INTERVAL = 1000;
        let refreshTimer = null;

        function formatTime(isoString) {
            if (!isoString) return '--:--:--';
            const date = new Date(isoString);
            if (Number.isNaN(date.getTime())) return '--:--:--';
            return date.toLocaleTimeString(undefined, {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        function formatDateTime(isoString) {
            if (!isoString) return '--';
            const date = new Date(isoString);
            if (Number.isNaN(date.getTime())) return '--';
            const y = String(date.getFullYear());
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            const h = String(date.getHours()).padStart(2, '0');
            const min = String(date.getMinutes()).padStart(2, '0');
            const s = String(date.getSeconds()).padStart(2, '0');
            return `${y}-${m}-${d} ${h}:${min}:${s}`;
        }

        function formatNumber(value, digits = 6) {
            if (value === null || value === undefined || Number.isNaN(value)) return '--';
            return Number(value).toFixed(digits);
        }

        async function fetchData() {
            try {
                const response = await fetch(API_URL, { cache: 'no-store' });
                if (response.status === 404) {
                    setConnectionStatus('waiting');
                    return;
                }
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();
                setConnectionStatus('connected');

                const last = document.getElementById('last-updated');
                last.textContent = formatTime(data.ts);
                last.title = data.ts || '';

                const meta = document.getElementById('snapshot-meta');
                const windowStart = data.window_start_ts ? formatDateTime(data.window_start_ts) : '--';
                const windowEnd = data.window_end_ts ? formatDateTime(data.window_end_ts) : '--';
                const tfMinutes = data.timeframe_minutes ? Number(data.timeframe_minutes) : null;
                const tfLabel = tfMinutes ? `${data.timeframe || '--'} (${tfMinutes}m close)` : (data.timeframe || '--');
                const metaParts = [
                    `${t('meta_timeframe')}: ${tfLabel}`,
                    `${t('meta_window')}: ${data.window_size || '--'} (${windowStart} → ${windowEnd})`,
                    `${t('meta_feature_dim')}: ${data.feature_dim || '--'}`,
                ];
                if (data.feature_meta) {
                    if (data.feature_meta.close !== undefined) {
                        metaParts.push(`${t('meta_close')}: ${formatNumber(data.feature_meta.close, 2)}`);
                    }
                    if (data.feature_meta.atr !== undefined) {
                        metaParts.push(`${t('meta_atr')}: ${formatNumber(data.feature_meta.atr, 6)}`);
                    }
                    if (data.feature_meta.volume !== undefined) {
                        metaParts.push(`${t('meta_volume')}: ${formatNumber(data.feature_meta.volume, 4)}`);
                    }
                }
                if (data.market && data.market.price !== undefined) {
                    const marketTime = data.market.ts ? formatTime(data.market.ts) : '--:--:--';
                    metaParts.push(`${t('meta_market')}: ${formatNumber(data.market.price, 2)} (${marketTime})`);
                }
                const liveCandle = data.live_candle || null;
                if (liveCandle && liveCandle.close_ts) {
                    const closeMs = new Date(liveCandle.close_ts).getTime();
                    const nowMs = Date.now();
                    const secondsLeft = Math.max(0, Math.round((closeMs - nowMs) / 1000));
                    const ageSec = liveCandle.age_sec !== undefined ? Number(liveCandle.age_sec) : null;
                    const ageLabel = ageSec !== null && !Number.isNaN(ageSec) ? `${ageSec.toFixed(1)}s` : '--';
                    metaParts.push(t('meta_live', { seconds: secondsLeft, age: ageLabel }));
                }
                meta.textContent = metaParts.join(' | ');

                const featuresBody = document.querySelector('#features-table tbody');
                featuresBody.innerHTML = '';
                (data.features || []).forEach((item) => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${item.name}</td><td>${formatNumber(item.value)}</td>`;
                    featuresBody.appendChild(tr);
                });
                if (!data.features || data.features.length === 0) {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td colspan="2" class="text-muted">${t('no_features')}</td>`;
                    featuresBody.appendChild(tr);
                }

                const candlesBody = document.querySelector('#candles-table tbody');
                candlesBody.innerHTML = '';
                let prevMs = null;
                if (liveCandle && liveCandle.close_ts) {
                    const tr = document.createElement('tr');
                    tr.className = 'table-warning';
                    const displayTs = liveCandle.close_ts || liveCandle.ts;
                    const candleTime = formatDateTime(displayTs);
                    const currentMs = displayTs ? new Date(displayTs).getTime() : null;
                    prevMs = currentMs;
                    tr.innerHTML = `
                        <td title="open: ${liveCandle.ts || ''}">${t('live_tag')} ${candleTime}</td>
                        <td>--</td>
                        <td>${formatNumber(liveCandle.open, 2)}</td>
                        <td>${formatNumber(liveCandle.high, 2)}</td>
                        <td>${formatNumber(liveCandle.low, 2)}</td>
                        <td>${formatNumber(liveCandle.close, 2)}</td>
                        <td>${formatNumber(liveCandle.volume, 4)}</td>
                    `;
                    candlesBody.appendChild(tr);
                }
                const candlesSorted = (data.candles || []).slice().sort((a, b) => {
                    const aTs = a.close_ts || a.ts || '';
                    const bTs = b.close_ts || b.ts || '';
                    return new Date(bTs).getTime() - new Date(aTs).getTime();
                });
                candlesSorted.forEach((candle) => {
                    const tr = document.createElement('tr');
                    const displayTs = candle.close_ts || candle.ts;
                    const candleTime = formatDateTime(displayTs);
                    const currentMs = displayTs ? new Date(displayTs).getTime() : null;
                    let gapText = '--';
                    let gapClass = '';
                    if (prevMs !== null && currentMs !== null) {
                        const diff = (prevMs - currentMs) / 60000;
                        gapText = diff.toFixed(1);
                        if (diff > 1.5) {
                            gapClass = 'gap-bad';
                        }
                    }
                    prevMs = currentMs;
                    tr.innerHTML = `
                        <td title="open: ${candle.ts || ''}">${candleTime}</td>
                        <td class="${gapClass}">${gapText}</td>
                        <td>${formatNumber(candle.open, 2)}</td>
                        <td>${formatNumber(candle.high, 2)}</td>
                        <td>${formatNumber(candle.low, 2)}</td>
                        <td>${formatNumber(candle.close, 2)}</td>
                        <td>${formatNumber(candle.volume, 4)}</td>
                    `;
                    candlesBody.appendChild(tr);
                });
                if ((!data.candles || data.candles.length === 0) && !liveCandle) {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td colspan="7" class="text-muted">${t('no_candles')}</td>`;
                    candlesBody.appendChild(tr);
                }
            } catch (error) {
                console.error('Error fetching data:', error);
                setConnectionStatus('disconnected');
            }
        }

        function startTimer() {
            if (refreshTimer) clearInterval(refreshTimer);
            fetchData();
            refreshTimer = setInterval(fetchData, AUTO_REFRESH_INTERVAL);
        }

        const checkbox = document.getElementById('autoRefresh');
        checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                startTimer();
            } else {
                clearInterval(refreshTimer);
            }
        });

        const langSelect = document.getElementById('lang-select');
        currentLang = detectLang();
        if (langSelect) {
            langSelect.value = currentLang;
            langSelect.addEventListener('change', (e) => {
                setLanguage(e.target.value);
                startTimer();
            });
        }
        setLanguage(currentLang);

        startTimer();
    </script>
</body>
</html>
