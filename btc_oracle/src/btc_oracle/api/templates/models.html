<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Oracle Models</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body { background-color: #f8f9fa; }
        .card { border: none; box-shadow: 0 4px 6px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .label-UP { color: #198754; }
        .label-DOWN { color: #dc3545; }
        .label-FLAT { color: #6c757d; }
        .label-UNCERTAIN { color: #fd7e14; }
        .table thead th { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.04em; }
        .table td { vertical-align: middle; }
    </style>
</head>
<body>
    <nav class="navbar navbar-dark bg-dark mb-4">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1"><i class="fas fa-layer-group me-2"></i><span data-i18n="brand">Model Predictions</span></span>
            <div class="d-flex align-items-center gap-2">
                <a class="btn btn-outline-light btn-sm" href="/" data-i18n="nav_dashboard">Dashboard</a>
                <a class="btn btn-outline-light btn-sm" href="/inputs" data-i18n="nav_inputs">Inputs</a>
                <a class="btn btn-outline-light btn-sm" href="/patterns" data-i18n="nav_patterns">Patterns</a>
                <select class="form-select form-select-sm bg-dark text-light border-secondary" id="lang-select" aria-label="Language" style="width: 86px;">
                    <option value="en">EN</option>
                    <option value="ru">RU</option>
                </select>
                <span class="text-light" id="connection-status"><span class="badge bg-success" data-i18n="status_connected">Connected</span></span>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="row mb-4">
            <div class="col-md-12">
                <div class="d-flex justify-content-between align-items-center">
                    <h5 class="text-muted mb-0"><span data-i18n="last_updated">Last Model Update</span>: <span id="last-updated">--:--:--</span> <small class="text-muted">(<span data-i18n="local">local</span>)</small></h5>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="autoRefresh" checked>
                        <label class="form-check-label" for="autoRefresh" data-i18n="auto_refresh">Auto-refresh (1s)</label>
                    </div>
                </div>
                <small class="text-muted d-block mt-2" data-i18n="heads_note">
                    UP/DOWN/FLAT are head probabilities from a single model. Vote is the policy decision derived from those heads.
                </small>
            </div>
        </div>

        <div id="models-container">
            <div class="col-12 text-center p-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden" data-i18n="loading">Loading...</span>
                </div>
                <p class="mt-2 text-muted" data-i18n="waiting_models">Waiting for model predictions...</p>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const LANG_KEY = 'titan_ui_lang';
        const I18N = {
            en: {
                title: 'BTC Oracle Models',
                brand: 'Model Predictions',
                nav_dashboard: 'Dashboard',
                nav_inputs: 'Inputs',
                nav_patterns: 'Patterns',
                status_connected: 'Connected',
                status_disconnected: 'Disconnected',
                last_updated: 'Last Model Update',
                local: 'local',
                auto_refresh: 'Auto-refresh (1s)',
                heads_note: 'UP/DOWN/FLAT are head probabilities from a single model. Vote is the policy decision derived from those heads.',
                loading: 'Loading...',
                waiting_models: 'Waiting for model predictions...',
                horizon_title: 'Horizon {value}m',
                table_model: 'Model',
                table_vote: 'Policy Vote',
                table_reason: 'Policy Reason',
                table_up: 'UP Head',
                table_down: 'DOWN Head',
                table_flat: 'FLAT Head',
                table_unc_dir: 'Unc Dir',
                table_unc_flat: 'Unc Flat',
                table_consensus: 'Consensus',
                table_weight: 'Weight',
                no_model_data: 'No model data',
                label_up: 'UP',
                label_down: 'DOWN',
                label_flat: 'FLAT',
                label_uncertain: 'UNCERTAIN',
            },
            ru: {
                title: 'BTC Oracle Модели',
                brand: 'Прогнозы моделей',
                nav_dashboard: 'Дашборд',
                nav_inputs: 'Входы',
                nav_patterns: 'Паттерны',
                status_connected: 'Подключено',
                status_disconnected: 'Нет связи',
                last_updated: 'Последнее обновление моделей',
                local: 'лок.',
                auto_refresh: 'Авто-обновление (1с)',
                heads_note: 'UP/DOWN/FLAT — вероятности голов одной модели. Vote — итоговое решение политики на базе этих голов.',
                loading: 'Загрузка...',
                waiting_models: 'Ожидание прогнозов моделей...',
                horizon_title: 'Горизонт {value}м',
                table_model: 'Модель',
                table_vote: 'Решение',
                table_reason: 'Причина',
                table_up: 'Голова UP',
                table_down: 'Голова DOWN',
                table_flat: 'Голова FLAT',
                table_unc_dir: 'Неопред. напр.',
                table_unc_flat: 'Неопред. флэт',
                table_consensus: 'Консенсус',
                table_weight: 'Вес',
                no_model_data: 'Нет данных модели',
                label_up: 'ВВЕРХ',
                label_down: 'ВНИЗ',
                label_flat: 'ФЛЭТ',
                label_uncertain: 'НЕОПРЕДЕЛЕННО',
            }
        };
        let connectionState = 'connected';
        let currentLang = null;

        function detectLang() {
            const saved = localStorage.getItem(LANG_KEY);
            if (saved) return saved;
            const browserLang = (navigator.language || '').toLowerCase();
            return browserLang.startsWith('ru') ? 'ru' : 'en';
        }

        function t(key, vars) {
            const dict = I18N[currentLang] || I18N.en;
            let text = dict[key] || I18N.en[key] || key;
            if (vars) {
                Object.keys(vars).forEach((k) => {
                    text = text.replace(new RegExp(`\\{${k}\\}`, 'g'), String(vars[k]));
                });
            }
            return text;
        }

        function applyTranslations(root = document) {
            root.querySelectorAll('[data-i18n]').forEach((el) => {
                el.textContent = t(el.dataset.i18n);
            });
            root.querySelectorAll('[data-i18n-title]').forEach((el) => {
                el.title = t(el.dataset.i18nTitle);
            });
        }

        function setLanguage(lang) {
            currentLang = I18N[lang] ? lang : 'en';
            localStorage.setItem(LANG_KEY, currentLang);
            document.documentElement.lang = currentLang;
            document.title = t('title');
            applyTranslations();
            setConnectionStatus(connectionState);
        }

        function setConnectionStatus(state) {
            connectionState = state;
            const el = document.getElementById('connection-status');
            if (!el) return;
            if (state === 'connected') {
                el.innerHTML = `<span class="badge bg-success">${t('status_connected')}</span>`;
            } else {
                el.innerHTML = `<span class="badge bg-danger">${t('status_disconnected')}</span>`;
            }
        }

        function localizeLabel(label) {
            const map = {
                UP: 'label_up',
                DOWN: 'label_down',
                FLAT: 'label_flat',
                UNCERTAIN: 'label_uncertain',
            };
            const key = map[label];
            return key ? t(key) : label;
        }

        const API_URL = '/api/models/latest';
        const CONFIG_URL = '/api/config';
        const AUTO_REFRESH_INTERVAL = 1000;
        let horizonOrder = ['1min', '5min', '10min', '15min', '30min', '60min'];
        let refreshTimer = null;

        function formatTime(isoString) {
            if (!isoString) return '--:--:--';
            const date = new Date(isoString);
            if (Number.isNaN(date.getTime())) return '--:--:--';
            return date.toLocaleTimeString(undefined, {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        function formatPercent(value, digits = 1) {
            if (value === null || value === undefined || Number.isNaN(value)) return '--';
            return (value * 100).toFixed(digits) + '%';
        }

        async function loadConfig() {
            try {
                const response = await fetch(CONFIG_URL, { cache: 'no-store' });
                if (!response.ok) return;
                const payload = await response.json();
                if (payload && Array.isArray(payload.horizons)) {
                    horizonOrder = payload.horizons
                        .slice()
                        .sort((a, b) => a - b)
                        .map((h) => `${h}min`);
                }
            } catch (error) {
                // keep defaults
            }
        }

        function renderHorizonBlock(horizonKey, payload) {
            const card = document.createElement('div');
            card.className = 'card p-3';

            const title = document.createElement('div');
            title.className = 'd-flex justify-content-between align-items-center mb-3';
            const badgeText = formatTime(payload.ts);
            title.innerHTML = `
                <h5 class="mb-0">${t('horizon_title', { value: horizonKey.replace('min', '') })}</h5>
                <span class="badge bg-light text-dark border" title="${payload.ts || ''}">${badgeText} <span class="text-muted">${t('local')}</span></span>
            `;
            card.appendChild(title);

            const table = document.createElement('table');
            table.className = 'table table-sm table-striped align-middle mb-0';
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>${t('table_model')}</th>
                        <th>${t('table_vote')}</th>
                        <th>${t('table_reason')}</th>
                        <th>${t('table_up')}</th>
                        <th>${t('table_down')}</th>
                        <th>${t('table_flat')}</th>
                        <th>${t('table_unc_dir')}</th>
                        <th>${t('table_unc_flat')}</th>
                        <th>${t('table_consensus')}</th>
                        <th>${t('table_weight')}</th>
                    </tr>
                </thead>
                <tbody></tbody>
            `;

            const tbody = table.querySelector('tbody');
            if (!payload.models || payload.models.length === 0) {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="10" class="text-muted">${t('no_model_data')}</td>`;
                tbody.appendChild(tr);
            } else {
                payload.models.forEach((model) => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td>${model.model_id || '--'}</td>
                        <td>${model.label ? localizeLabel(model.label) : '--'}</td>
                        <td class="text-muted">${model.reason_code || '--'}</td>
                        <td>${formatPercent(model.p_up)}</td>
                        <td>${formatPercent(model.p_down)}</td>
                        <td>${formatPercent(model.p_flat)}</td>
                        <td>${model.u_dir !== undefined ? model.u_dir.toFixed(3) : '--'}</td>
                        <td>${model.u_mag !== undefined ? model.u_mag.toFixed(3) : '--'}</td>
                        <td>${model.consensus !== undefined ? model.consensus.toFixed(3) : '--'}</td>
                        <td>${formatPercent(model.weight)}</td>
                    `;
                    tbody.appendChild(tr);
                });
            }

            card.appendChild(table);
            return card;
        }

        async function fetchData() {
            try {
                const response = await fetch(API_URL, { cache: 'no-store' });
                if (!response.ok) throw new Error('Network response was not ok');
                const data = await response.json();
                setConnectionStatus('connected');

                const container = document.getElementById('models-container');
                container.innerHTML = '';

                const sortedKeys = horizonOrder.length ? horizonOrder : Object.keys(data).sort();
                let allTs = [];

                sortedKeys.forEach((key) => {
                    const payload = data[key];
                    if (!payload) return;
                    if (payload.ts) {
                        const parsed = new Date(payload.ts);
                        if (!Number.isNaN(parsed.getTime())) {
                            allTs.push(parsed.getTime());
                        }
                    }
                    container.appendChild(renderHorizonBlock(key, payload));
                });

                if (allTs.length) {
                    const latest = new Date(Math.max(...allTs));
                    document.getElementById('last-updated').textContent = formatTime(latest.toISOString());
                } else {
                    document.getElementById('last-updated').textContent = '--:--:--';
                }
            } catch (error) {
                console.error('Error fetching data:', error);
                setConnectionStatus('disconnected');
            }
        }

        function startTimer() {
            if (refreshTimer) clearInterval(refreshTimer);
            loadConfig().finally(() => fetchData());
            refreshTimer = setInterval(fetchData, AUTO_REFRESH_INTERVAL);
        }

        const checkbox = document.getElementById('autoRefresh');
        checkbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                startTimer();
            } else {
                clearInterval(refreshTimer);
            }
        });

        const langSelect = document.getElementById('lang-select');
        currentLang = detectLang();
        if (langSelect) {
            langSelect.value = currentLang;
            langSelect.addEventListener('change', (e) => {
                setLanguage(e.target.value);
                startTimer();
            });
        }
        setLanguage(currentLang);

        startTimer();
    </script>
</body>
</html>
